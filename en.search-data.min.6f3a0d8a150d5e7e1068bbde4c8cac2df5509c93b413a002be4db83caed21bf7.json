[{"id":0,"href":"/software-quality/principles/separation-of-concerns/","title":"Separation of Concerns","section":"Principles","content":" This Principle is Special # Separation of Concerns is the most important principle to follow when solving complex problems. All other design principles I follow are just re-wordings or specific examples of separating concerns, which is why I list this principle first.\nWhat is it? # Each component of your solution should solve a single logical sub-problem. A given sub-problem may also be divided, and sub-components created to solve sub-problems.\nWhy? # Makes it easy to figure out where you need to make a new change or debug an issue Makes it easy to generalize your solution to new but similar problems, by reusing pars of your design (see also \u0026ldquo;The Rule of Two\u0026rdquo;) Minimizes the number of changes you need to make in the future (see also \u0026ldquo;Do Not Repeat Yourself\u0026rdquo;) Makes it easy for different teams to own each component (see also \u0026ldquo;Ownership\u0026rdquo;, \u0026ldquo;Focus\u0026rdquo; and \u0026ldquo;Minimizing Interfaces\u0026rdquo;) Helps to isolate complexity so that it doesn\u0026rsquo;t leak everywhere (see also \u0026ldquo;Managing Complexity\u0026rdquo; and \u0026ldquo;Clean Abstractions\u0026rdquo;) Makes it easy to determine whether a dependency is unavoidable (see also \u0026ldquo;Minimizing Dependencies\u0026rdquo;) Helps you figure out which pieces are needed right away vs later (see also \u0026ldquo;Design Incrementally\u0026rdquo;) Examples # WIP\n"},{"id":1,"href":"/software-quality/project-lifecycle/","title":"Project Lifecycle","section":"","content":" Lifecycle of a Software Project # Each section below describes one phase of a software project.\nRequirements Gathering Decide what problem we\u0026rsquo;re going to solve, and what \u0026ldquo;solved\u0026rdquo; means. Design Decide how we will meet all of the requirements. Planning Decide who will execute the approved plan, by when. Implementation Develop the proposed software. Release Ensure the system is ready for release and meets all applicable standards. Operation Operate, fix and improve the system. Deprecation Decommission or replace the system when it becomes obsolete. "},{"id":2,"href":"/software-quality/project-lifecycle/requirements-gathering/","title":"Requirements Gathering","section":"Project Lifecycle","content":" Overview # In this phase you will produce the requirements portion of a Design Document and get that approved.\nHow to Think About Requirements # FORGET everything you know about the current solution! DON\u0026rsquo;T try to come up with a new solution! FOCUS on understanding the customer, their goals and experiences! ONCE you understand the customer, feel free to ask \u0026ldquo;what if X?\u0026rdquo; X should expose as little implementation detail as possible X should focus as much as possible on the user\u0026rsquo;s experience: the user\u0026rsquo;s actions, what they see, hear and feel Target State, and How to Get There # You want several stakeholders to approve a set of measurable goals. This means you\u0026rsquo;re juggling many interests at once. Your requirements must:\nImpress a customer or Product Manager This means (for projects with non-tech customers) a non-engineer has to understand how the new experience will be better This means the requirements have to be as non-technical as possible This means that a mockup may be needed to fully explain the requirements Seem like a small enough investment to Engineers and Managers to be worth the benefits This means you have to be thinking ahead to possible designs You need to have \u0026ldquo;ideal ways\u0026rdquo; and \u0026ldquo;shortcutted ways\u0026rdquo; in mind You need to believe that these requirements won\u0026rsquo;t become irrelevant later Specializing the Pitch # Your pitch needs to be expressed in a way your customer and key approvers will understand.\nEngineers These people tend to want hints about the solution before you\u0026rsquo;ve posed a problem Try to distract them from the solution and focus them on the problem :) Product Managers / Managers These people are specifically trained to help you get the right requirements Pull them into the discussion even if they aren\u0026rsquo;t the customer :) End Users These people may not understand what it\u0026rsquo;ll cost you to build this. Avoid over-promising, but see what will give them the biggest incremental boost :) Steps # Identify who the customers are Identify a list of \u0026ldquo;key approvers\u0026rdquo; (individual humans, not teams) Understand what the customers do, and what their day-to-day goals are Narrow down and focus on the \u0026ldquo;core\u0026rdquo; problem that is causing the worst effects Come up with some proposed goals which, if reached, would solve the core problem Propose and get approval on: A summary of the problem the project will solve A list of concrete, measurable goals for the project to achieve A list of things the project will NOT achieve (\u0026ldquo;out of scope\u0026rdquo;) Problem Statement # If the problem statement isn\u0026rsquo;t concrete (based on the customer\u0026rsquo;s experience), it\u0026rsquo;s not done yet If the problem statement describes several very different problems, you need to focus it more If the problem statement is being misunderstood, it needs to be clarified Functional Requirements # These explain what new functionality we need to build for the customer.\nMust say something about the experience the customer will have Must be easy for the customer to understand Should hint to engineers some \u0026ldquo;unit of functionality\u0026rdquo; to be built If building on an existing system, specify how it will affect the user\u0026rsquo;s experience of that system Templates: \u0026ldquo;As a {customer type}, when {activity} I can {action} in {location}, and that will result in {outcome}\u0026rdquo; \u0026ldquo;As a {customer type}, when {activity} I can see {information} in {location}\u0026rdquo; This has to be the kind of thing you (and the customer) can test when you\u0026rsquo;re done, to prove that it\u0026rsquo;s complete. You can mix and match the templates above. They provide some useful constraints that will guide you toward better requirements.\nNon-Functional Requirements # These explain other aspects of the system, or the new functionality, in order to keep the experience high quality, and handle the needs of the business and developers.\nUser-facing latency and availability SLAs Applicable Operations, Security and Privacy requirements Out of Scope # These explain things you will not achieve. It is best for these to be worded similarly to Functional Requirements, but sometimes you need to just explain something your own way and that\u0026rsquo;s fine.\nWhen Am I Done? # When you\u0026rsquo;ve filled in the Requirements section of this design doc template and gotten it approved by your key approvers.\n"},{"id":3,"href":"/software-quality/standards/","title":"Standards","section":"","content":" Standards # Each of the items below is a standard. A standard is either a document template or a checklist, which provides a pre-built structure for you to follow.\nDesign Template A design doc template you can fill in to easily create a comprehensive design. Wish List # Launch Plan Operations Checklist Security Audit Privacy Audit Roadmap Decision Document Product Demo Meeting On-Call Run book Task Template Code Review Checklist Incident Report "},{"id":4,"href":"/software-quality/project-lifecycle/design/","title":"Design","section":"Project Lifecycle","content":"In this phase you will produce a Design Document, and get that approved. At a high level what you need to do is:\nWhat Does A Design Doc Do? # Reference the requirements you are trying to meet Lay out the logical \u0026ldquo;components\u0026rdquo; and describe how they will work together Specify the inner function of each component You can delegate this to sub-designs with more technically-focused requirements Specify what technical decisions were made and why Address cross-cutting concerns (operations, security, extensibility) Provide a breakdown of the needed work, with estimates of how much engineer time each step will take Get all the way down to individual tasks, even if it means making sub-designs Get approval from all people and teams who will probably be involved in the work How to think through a design # Figure out what the fundamental shape of the problem is Create [\u0026ldquo;action/information\u0026rdquo; flow diagrams] Group sets of actions in the flow diagram that can serve as distinct components Each component should be uniquely identified by a clear, independent responsibility (see \u0026ldquo;Separation of Concerns\u0026rdquo;) Try many different breakdowns Get into how each component will be implemented What would each component look like? A service? A DB? A library? A webpage? Think about applicable [System Archetypes] Think about whether anyone else in your company is solving each subproblem Dive into the details What does the data flowing between the components look like? What is the specific interface of each component (inputs, outputs) What happens when something goes wrong in a component? What is the exact sequence of interactions that will happen? If your problem is very large, you may have multiple \u0026ldquo;sub-breakdown\u0026rdquo; stages before you get to hard details \u0026ndash; in those cases it may be appropriate to have one \u0026ldquo;High-Level Design\u0026rdquo; doc as well as \u0026ldquo;Component Design\u0026rdquo; docs.\nWhen Am I Done? # When you\u0026rsquo;ve filled in this whole design doc template and gotten it approved by your key approvers.\nNOTE: You can get informal approval in 3 phases as you build the document:\nRequirements, to make sure you\u0026rsquo;re solving the right problem Proposal, to make sure your overall approach makes sense Details, to make sure you\u0026rsquo;re getting all the details right and it\u0026rsquo;s ready for planning "},{"id":5,"href":"/software-quality/principles/","title":"Principles","section":"","content":" Software Principles # Each page below describes one principle you can use to guide your software engineering work.\nSeparation of Concerns The key to everything Wish List # Solving Problems The Rule of Two Expect Change Do Not Repeat Yourself Clean Abstractions Minimize Interfaces Managing Complexity Minimizing Dependencies Design Incrementally People and Organizations If They Can, They Will If It\u0026rsquo;s Not Written, It\u0026rsquo;s Not Happening What Ownership Is The Problem with Deprecation Cross Cutting Concerns Testing is Mandatory Isolating Tests "},{"id":6,"href":"/software-quality/project-lifecycle/planning/","title":"Planning","section":"Project Lifecycle","content":" Break the plan down into independent \u0026ldquo;workstreams\u0026rdquo; Decide who will work on each workstream Break down each workstream into a sequence of \u0026ldquo;milestones\u0026rdquo; with clear deliverables Determine when each milestone will be done by Identify risks to the plan, and add buffer time or resources Get approval from management, and the people who will work on this "},{"id":7,"href":"/software-quality/project-lifecycle/implementation/","title":"Implementation","section":"Project Lifecycle","content":" Write code Ensure sufficient testing and documentation as you go Ensure all code and documentation is reviewed Check your progress against requirements periodically You should demo the product to key approvers periodically Adjust the roadmap or design as needed Decide you are ready to release the new system! "},{"id":8,"href":"/software-quality/project-lifecycle/release/","title":"Release","section":"Project Lifecycle","content":" Get Customer Approval Complete Operations, Security and Privacy Checklists To the extent possible, these should be automated Not all checklist items are always relevant Define a release plan How will we execute the release? What could go wrong? What will we do about it? Get approval on the artifacts above Execute the release plan "},{"id":9,"href":"/software-quality/project-lifecycle/operation/","title":"Operation","section":"Project Lifecycle","content":" Monitor the system, manage an on-call rotation Mitigate incidents, if applicable Address customer feedback Fix bugs Plan improvements (these also follow the same lifecycle) Determine if the system needs to be deprecated (usually as part of a new project) "},{"id":10,"href":"/software-quality/project-lifecycle/deprecation/","title":"Deprecation","section":"Project Lifecycle","content":" Identify and measure impact of all affected customer use cases Identify any actions needed to migrate customers to a new system Make an inventory of all the components that need to be decommissioned Perform any needed migrations Shut down the system "},{"id":11,"href":"/software-quality/standards/design-template/","title":"Design Template","section":"Standards","content":" Instructions # Replace italicized items like {your name here} Follow instructions in any big red banners like this one Review the document yourself to verify you\u0026rsquo;ve followed instructions Delete all of the red banners and any leftover notes [Design] {Project Name Here} # Author(s): {Author1, Author2} Status: {Draft/Approved} Pick the people who need to approve this design. You could reasonably include:\nExperts on the systems that need to be changed People who are planning to work on this Senior engineers Key points of contact from teams who will also work on this Product managers (tech or not), to approve on behalf of customers Reviewers are allowed to ask for more reviewers - that\u0026rsquo;s why this table is here.\nKey Approver Representing Status Notes {approver1} {team/org/system} {Pending/Approved} {comments go here} {approver2} {team/org/system} {Pending/Approved} {comments go here} {approver3} {team/org/system} {Pending/Approved} {comments go here} Requirements # This section sets the \u0026ldquo;definition of done\u0026rdquo;. See Requirements Gathering Phase.\nIt is reasonable to ensure the requirements are reviewed by some of your stakeholders BEFORE you write the design. This helps make sure you\u0026rsquo;re designing for the right problem.\nYou could go so far as to split this into its own separate doc, and just reference the requirements doc when you write the design portion.\nProblem Statement # Write a plain-language paragraph or two to explains:\nWho the customer is What they do and what problem they have A vision for what \u0026ldquo;solved\u0026rdquo; looks like The customer could be your business\u0026rsquo; end-customer, another business, a set of internal teams or even your own team. You can address multiple customers if needed.\nFunctional Requirements # Write a numbered bulleted list of \u0026ldquo;requirements\u0026rdquo;. These are concrete, measurable goals you can easily see if you\u0026rsquo;ve reached or not. These have to be done for the project to be considered done.\nFunctional requirements focus on \u0026ldquo;functionality we will provide\u0026rdquo;. Examples:\nThe customer can click on the \u0026ldquo;hello\u0026rdquo; button to receive a \u0026ldquo;hello\u0026rdquo; email All filed customer complaints will be stored permanently I can send an emoji with a format like :happyface: The breadth or focus of ALL requirements depends on the breadth or focus of the project.\nIf the whole goal of the project is to improve non-functional aspects of the system, those can be listed here and you can remove the non-functional requirements section.\nNon-Functional Requirements # Write a numbered bulleted list of \u0026ldquo;requirements\u0026rdquo;. These are concrete, measurable goals you can easily see if you\u0026rsquo;ve reached or not. These have to be done for the project to be considered done.\nNon-functional requirements focus on \u0026ldquo;how we will provide our functionality\u0026rdquo;. Examples:\nThe \u0026ldquo;create\u0026rdquo; operation will meet a latency SLA of 5ms @ P95 The \u0026ldquo;create\u0026rdquo; operation will handle 90 QPS without performance degradation No engineer effort should be required for a customer to file a complaint This project will meet all operations, security and privacy standards of our org The breadth or focus of ALL requirements depends on the breadth or focus of the project.\nOut of Scope # Write a numbered bulleted list of \u0026ldquo;NON-requirements\u0026rdquo;. These are things this project will NOT achieve. You write these down to prevent people from asking \u0026ldquo;wait, this doesn\u0026rsquo;t solve X?\u0026rdquo; Proposal # This section specifies at a high level our solution to the problem. See Design Phase.\nAvoid getting into fine details until later.\nOverview # Provide a diagram that shows the components of your system, as well as any neighboring systems it interacts with.\nColor scheme should be used to show:\nWhich components need changes Which components are new Which components will be deprecated Which components will be unaffected (\u0026ldquo;out of scope\u0026rdquo;) Components # For each component, describe:\nSummary of its purpose, how it works and how it interacts with other components Its API \u0026ndash; inputs, outputs, side-effects High level logic behind the API You want a digestible amount of detail here. Don\u0026rsquo;t go too deep.\nIn some cases you will want a \u0026ldquo;sub-design\u0026rdquo; for some of these components. If so, you should mention that when you describe the component.\n{Component 1} # {Component 2} # {Component 3} # Alternatives # Explain what alternative approaches you considered.\nIf there were multiple choices on a certain component, you could make one section explaining those choices, and the tradeoffs that led you to your decision.\nThis is where you really show your work, and the thought process you followed.\n{Why Not X?} # {Why Not Y?} # Detailed Notes # This section makes an inventory of applicable standards, and explains how we will meet all of them with the proposed design.\nNote that there might be finer details here that were not covered in the proposal section.\nI often hold off on writing all of the detailed notes until I\u0026rsquo;m confident in my proposal \u0026ndash; otherwise you\u0026rsquo;ll have to revise these when one of your alternatives is found to be preferred.\nRelease Process # How will you release the new functionality.\nAn upcoming standard will provide guidance on this.\nOperations # How will you:\nPrevent and mitigate system failures or other incidents Test the system continuously to catch issues early Protect the system from breaking when new code is released Minimize the cost of maintaining the system An upcoming standard will provide guidance on this.\nSecurity # How will you prevent the system from being abused or exploited?\nIf the system is built for security or privacy enforcement, the high-level of this should be covered in Proposal, and you can focus on finer details here.\nPrivacy # How will you protect customer data, and ensure that it is handled in accordance with:\nTheir expectations Applicable regulations, in the locations where the system operates An upcoming standard will provide guidance on this.\n{Component 1 Deep-Dive} # Not all components need a full deep-dive, but it can be helpful in case you don\u0026rsquo;t want to create a whole new design doc just for that component / there isn\u0026rsquo;t quite enough ambiguity for that. "}]